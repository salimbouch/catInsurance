/*
 * Cat Insurance API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"

	"context"
	"log"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/secretsmanager"
	"github.com/google/uuid"

	_ "github.com/go-sql-driver/mysql"
	"github.com/gorilla/mux"
)

type DBCredentials struct {
	Username string `json:"username"`
	Password string `json:"password"`
	Host     string `json:"host"`
	Port     int    `json:"port"`
}

// Function to retrieve database credentials from Secrets Manager
func getDBCredentials() (DBCredentials, error) {
	var dbCredentials DBCredentials

	region := "eu-central-1"
	secretName := "prod/catInsurance/mysql"

	cfg, err := config.LoadDefaultConfig(context.TODO(),
		config.WithRegion(region),
	)
	if err != nil {
		return DBCredentials{}, fmt.Errorf("failed to load AWS configuration: %v", err)
	}

	svc := secretsmanager.NewFromConfig(cfg)
	input := &secretsmanager.GetSecretValueInput{
		SecretId:     aws.String(secretName),
		VersionStage: aws.String("AWSCURRENT"),
	}

	result, err := svc.GetSecretValue(context.TODO(), input)
	if err != nil {
		return DBCredentials{}, fmt.Errorf("failed to retrieve database credentials from Secrets Manager: %v", err)
	}

	secretString := *result.SecretString

	// Parse the JSON secret string
	if err := json.Unmarshal([]byte(secretString), &dbCredentials); err != nil {
		return DBCredentials{}, fmt.Errorf("error parsing database credentials: %v", err)
	}

	return dbCredentials, nil
}

// Use getDBCredentials function to retrieve database credentials
func connectToDB() (*sql.DB, error) {
	// Retrieve database credentials
	dbCredentials, err := getDBCredentials()
	if err != nil {
		return nil, err
	}

	// Format the DSN for connecting to the MySQL database
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/meowmeddb", dbCredentials.Username, dbCredentials.Password, dbCredentials.Host, dbCredentials.Port)

	// Connect to the database
	db, err := sql.Open("mysql", dsn)
	if err != nil {
		return nil, fmt.Errorf("error connecting to database: %v", err)
	}

	return db, nil
}

func CustomersCustomerIdGet(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	customerID := vars["customerId"]

	if customerID == "" {
		http.Error(w, "Missing customerId parameter", http.StatusBadRequest)
		return
	}

	db, err := connectToDB()
	if err != nil {
		http.Error(w, "Error connecting to database", http.StatusInternalServerError)
		log.Fatal(err)
		return
	}
	defer db.Close()

	// Query to retrieve customer details with JOIN
	var customer CustomerRes

	// Initialize Address and BankDetails fields
	customer.Address = &Address{}
	customer.BankDetails = &BankDetails{}

	err = db.QueryRowContext(r.Context(), `
    SELECT
        c.id, c.firstName, c.lastName, COALESCE(c.title, '') AS title, c.familyStatus, c.birthDate,
        c.socialSecurityNumber, c.taxId, c.jobStatus,
        a.street, a.houseNumber, a.zipCode, a.city,
        b.iban, b.bic, b.name AS bankName
    FROM
        Customer AS c
    JOIN
        Address AS a ON c.addressId = a.id
    JOIN
        BankDetails AS b ON c.bankDetailsId = b.id
    WHERE
        c.id = ?`, customerID).Scan(
		&customer.Id, &customer.FirstName, &customer.LastName, &customer.Title, &customer.FamilyStatus, &customer.BirthDate,
		&customer.SocialSecurityNumber, &customer.TaxId, &customer.JobStatus,
		&customer.Address.Street, &customer.Address.HouseNumber, &customer.Address.ZipCode, &customer.Address.City,
		&customer.BankDetails.Iban, &customer.BankDetails.Bic, &customer.BankDetails.Name)
	if err != nil {
		log.Printf("Error retrieving customer details: %v", err)
		http.Error(w, "Error retrieving customer details", http.StatusInternalServerError)
		return
	}

	// Serialize customer details into JSON format
	responseJSON, err := json.Marshal(customer)
	if err != nil {
		http.Error(w, "Error serializing customer details", http.StatusInternalServerError)
		return
	}

	// Set Content-Type header to indicate JSON response
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	// Write the JSON response back to the client
	w.WriteHeader(http.StatusOK)
	w.Write(responseJSON)
}

func CustomersGet(w http.ResponseWriter, r *http.Request) {
	// Parse query parameters
	page, err := strconv.Atoi(r.URL.Query().Get("page"))
	if err != nil || page < 1 {
		page = 1 // Default to page 1 if the page parameter is missing or invalid
	}

	pageSize, err := strconv.Atoi(r.URL.Query().Get("pageSize"))
	if err != nil || pageSize < 1 {
		pageSize = 20 // Default page size if pageSize parameter is missing or invalid
	}

	// Calculate offset based on page number and page size
	offset := (page - 1) * pageSize

	db, err := connectToDB()
	if err != nil {
		http.Error(w, "Error connecting to database", http.StatusInternalServerError)
		log.Fatal(err)
		return
	}
	defer db.Close()

	// Query to retrieve paginated customer details
	rows, err := db.QueryContext(r.Context(), `
    SELECT
        c.id, c.firstName, c.lastName, COALESCE(c.title, '') AS title, c.familyStatus, c.birthDate,
        c.socialSecurityNumber, c.taxId, c.jobStatus,
        a.street, a.houseNumber, a.zipCode, a.city,
        b.iban, b.bic, b.name AS bankName
    FROM
        Customer AS c
    JOIN
        Address AS a ON c.addressId = a.id
    JOIN
        BankDetails AS b ON c.bankDetailsId = b.id
    ORDER BY c.id ASC
    LIMIT ? OFFSET ?`, pageSize, offset)
	if err != nil {
		http.Error(w, "Error retrieving customer details", http.StatusInternalServerError)
		log.Fatal(err)
		return
	}
	defer rows.Close()

	// Construct slice to hold customer details
	var customers []CustomerRes

	// Iterate over the rows and populate the customers slice
	for rows.Next() {
		var customer CustomerRes
		customer.Address = &Address{}
		customer.BankDetails = &BankDetails{}
		if err := rows.Scan(
			&customer.Id, &customer.FirstName, &customer.LastName, &customer.Title, &customer.FamilyStatus, &customer.BirthDate,
			&customer.SocialSecurityNumber, &customer.TaxId, &customer.JobStatus,
			&customer.Address.Street, &customer.Address.HouseNumber, &customer.Address.ZipCode, &customer.Address.City,
			&customer.BankDetails.Iban, &customer.BankDetails.Bic, &customer.BankDetails.Name,
		); err != nil {
			http.Error(w, "Error scanning customer details", http.StatusInternalServerError)
			log.Fatal(err)
			return
		}

		// Append customer details to the customers slice
		customers = append(customers, customer)
	}

	// Check for errors during rows iteration
	if err := rows.Err(); err != nil {
		http.Error(w, "Error iterating over customer details", http.StatusInternalServerError)
		log.Fatal(err)
		return
	}

	// Convert customers slice to JSON
	responseJSON, err := json.Marshal(customers)
	if err != nil {
		http.Error(w, "Error serializing customer details", http.StatusInternalServerError)
		log.Fatal(err)
		return
	}

	// Write JSON response
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	w.Write(responseJSON)
}

func CustomersPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	// Read request body
	var newCustomerReq CustomerReq
	if err := json.NewDecoder(r.Body).Decode(&newCustomerReq); err != nil {
		http.Error(w, "Error decoding request body", http.StatusBadRequest)
		return
	}

	// Retrieve database credentials
	db, err := connectToDB()
	if err != nil {
		http.Error(w, "Error connecting to database", http.StatusInternalServerError)
		log.Fatal(err)
		return
	}
	defer db.Close()

	// Begin transaction
	tx, err := db.Begin()
	if err != nil {
		http.Error(w, "Error starting transaction", http.StatusInternalServerError)
		return
	}

	// Insert into Address table
	addressID := uuid.New().String() // Generate UUID for the address
	_, err = tx.ExecContext(context.Background(), `
			INSERT INTO Address (id, street, houseNumber, zipCode, city)
			VALUES (?, ?, ?, ?, ?)`,
		addressID, newCustomerReq.Address.Street, newCustomerReq.Address.HouseNumber, newCustomerReq.Address.ZipCode, newCustomerReq.Address.City)
	if err != nil {
		tx.Rollback()
		http.Error(w, "Error inserting into Address table", http.StatusInternalServerError)
		return
	}

	// Insert into BankDetails table
	bankDetailsID := uuid.New().String() // Generate UUID for the bank details
	_, err = tx.ExecContext(context.Background(), `
			INSERT INTO BankDetails (id, iban, bic, name)
			VALUES (?, ?, ?, ?)`,
		bankDetailsID, newCustomerReq.BankDetails.Iban, newCustomerReq.BankDetails.Bic, newCustomerReq.BankDetails.Name)
	if err != nil {
		tx.Rollback()
		http.Error(w, "Error inserting into BankDetails table", http.StatusInternalServerError)
		return
	}

	// Generate UUID for the new customer
	newCustomerID := uuid.New().String()

	// Insert into Customer table
	_, err = tx.ExecContext(context.Background(), `
			INSERT INTO Customer (id, firstName, lastName, title, familyStatus, birthDate, socialSecurityNumber, taxId, jobStatus, addressId, bankDetailsId)
			VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
		newCustomerID, newCustomerReq.FirstName, newCustomerReq.LastName, newCustomerReq.Title, newCustomerReq.FamilyStatus, newCustomerReq.BirthDate,
		newCustomerReq.SocialSecurityNumber, newCustomerReq.TaxId, newCustomerReq.JobStatus, addressID, bankDetailsID)
	if err != nil {
		tx.Rollback()
		http.Error(w, "Error inserting into Customer table", http.StatusInternalServerError)
		return
	}

	// Commit transaction
	if err := tx.Commit(); err != nil {
		http.Error(w, "Error committing transaction", http.StatusInternalServerError)
		return
	}

	// Respond with the new customer details
	newCustomerRes := CustomerRes{
		Id:                   newCustomerID,
		FirstName:            newCustomerReq.FirstName,
		LastName:             newCustomerReq.LastName,
		Title:                newCustomerReq.Title,
		FamilyStatus:         newCustomerReq.FamilyStatus,
		BirthDate:            newCustomerReq.BirthDate,
		SocialSecurityNumber: newCustomerReq.SocialSecurityNumber,
		TaxId:                newCustomerReq.TaxId,
		JobStatus:            newCustomerReq.JobStatus,
		Address: &Address{
			Street:      newCustomerReq.Address.Street,
			HouseNumber: newCustomerReq.Address.HouseNumber,
			ZipCode:     newCustomerReq.Address.ZipCode,
			City:        newCustomerReq.Address.City,
		},
		BankDetails: &BankDetails{
			Iban: newCustomerReq.BankDetails.Iban,
			Bic:  newCustomerReq.BankDetails.Bic,
			Name: newCustomerReq.BankDetails.Name,
		},
	}

	responseJSON, err := json.Marshal(newCustomerRes)
	if err != nil {
		http.Error(w, "Error serializing customer details", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusCreated)
	w.Write(responseJSON)
}

func CustomersCustomerIdDelete(w http.ResponseWriter, r *http.Request) {
	// Extract customer ID from request URL
	vars := mux.Vars(r)
	customerID := vars["customerId"]

	if customerID == "" {
		http.Error(w, "Missing customerId parameter", http.StatusBadRequest)
		return
	}

	// Retrieve database connection
	db, err := connectToDB()
	if err != nil {
		http.Error(w, "Error connecting to database: "+err.Error(), http.StatusInternalServerError)
		log.Fatal(err)
		return
	}
	defer db.Close()

	var addressID, bankDetailsID string

	// Begin transaction
	tx, err := db.Begin()
	if err != nil {
		http.Error(w, "Error starting transaction: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// Save address ID and bank details ID
	err = tx.QueryRowContext(context.Background(), `
        SELECT addressId, bankDetailsId FROM Customer WHERE id = ?`, customerID).Scan(&addressID, &bankDetailsID)
	if err != nil {
		tx.Rollback()
		http.Error(w, "Error retrieving customer details: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// Delete associated contracts
	_, err = tx.ExecContext(context.Background(), `
        DELETE FROM Contract WHERE customerId = ?`, customerID)
	if err != nil {
		tx.Rollback()
		http.Error(w, "Error deleting associated contracts: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// Delete the customer
	_, err = tx.ExecContext(context.Background(), `
        DELETE FROM Customer WHERE id = ?`, customerID)
	if err != nil {
		tx.Rollback()
		http.Error(w, "Error deleting customer: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// Delete customer's address
	_, err = tx.ExecContext(context.Background(), `
        DELETE FROM Address WHERE id = ?`, addressID)
	if err != nil {
		tx.Rollback()
		http.Error(w, "Error deleting customer's address: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// Delete customer's bank details
	_, err = tx.ExecContext(context.Background(), `
        DELETE FROM BankDetails WHERE id = ?`, bankDetailsID)
	if err != nil {
		tx.Rollback()
		http.Error(w, "Error deleting customer's bank details: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// Commit transaction
	if err := tx.Commit(); err != nil {
		http.Error(w, "Error committing transaction: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// Respond with success message
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("Customer deleted"))
}

func CustomersSearchGet(w http.ResponseWriter, r *http.Request) {
	// Parse query parameters
	queryParams := r.URL.Query()
	page, err := strconv.Atoi(queryParams.Get("page"))
	if err != nil || page < 1 {
		page = 1 // Default to page 1 if the page parameter is missing or invalid
	}

	pageSize, err := strconv.Atoi(queryParams.Get("pageSize"))
	if err != nil || pageSize < 1 {
		pageSize = 20 // Default page size if pageSize parameter is missing or invalid
	}

	// Build the SQL query and parameter list
	var args []interface{}
	sqlQuery := "SELECT c.id, c.firstName, c.lastName, c.title, c.familyStatus, c.birthDate, c.socialSecurityNumber, c.taxId, c.jobStatus, " +
		"a.street, a.houseNumber, a.zipCode, a.city, " +
		"b.iban, b.bic, b.name " +
		"FROM Customer c " +
		"INNER JOIN Address a ON c.addressId = a.id " +
		"INNER JOIN BankDetails b ON c.bankDetailsId = b.id " +
		"WHERE 1=1"

	if id := queryParams.Get("id"); id != "" {
		sqlQuery += " AND c.id = ?"
		args = append(args, id)
	}
	if name := queryParams.Get("name"); name != "" {
		sqlQuery += " AND c.firstName = ?"
		args = append(args, name)
	}
	if lastName := queryParams.Get("lastName"); lastName != "" {
		sqlQuery += " AND c.lastName = ?"
		args = append(args, lastName)
	}
	if address := queryParams.Get("address"); address != "" {
		sqlQuery += " AND a.street = ?"
		args = append(args, address)
	}

	// Add pagination to the SQL query
	sqlQuery += " LIMIT ? OFFSET ?"
	args = append(args, pageSize, (page-1)*pageSize)

	// Execute the SQL query
	db, err := connectToDB()
	if err != nil {
		http.Error(w, "Error connecting to database", http.StatusInternalServerError)
		log.Fatal(err)
		return
	}
	defer db.Close()

	rows, err := db.QueryContext(r.Context(), sqlQuery, args...)
	if err != nil {
		http.Error(w, "Error retrieving customer details "+err.Error(), http.StatusInternalServerError)
		log.Fatal(err)
		return
	}
	defer rows.Close()

	// Construct slice to hold customer details
	var customers []CustomerRes

	// Iterate over the rows and populate the customers slice
	for rows.Next() {
		var customer CustomerRes
		customer.Address = &Address{}
		customer.BankDetails = &BankDetails{}
		if err := rows.Scan(
			&customer.Id,
			&customer.FirstName,
			&customer.LastName,
			&customer.Title,
			&customer.FamilyStatus,
			&customer.BirthDate,
			&customer.SocialSecurityNumber,
			&customer.TaxId,
			&customer.JobStatus,
			&customer.Address.Street,
			&customer.Address.HouseNumber,
			&customer.Address.ZipCode,
			&customer.Address.City,
			&customer.BankDetails.Iban,
			&customer.BankDetails.Bic,
			&customer.BankDetails.Name); err != nil {
			http.Error(w, "Error scanning customer details", http.StatusInternalServerError)
			log.Fatal(err)
			return
		}

		// Append customer details to the customers slice
		customers = append(customers, customer)
	}

	// Check for errors during rows iteration
	if err := rows.Err(); err != nil {
		http.Error(w, "Error iterating over customer details", http.StatusInternalServerError)
		log.Fatal(err)
		return
	}

	if len(customers) == 0 {
		w.WriteHeader(http.StatusNoContent)
		return
	}

	// Convert customers slice to JSON
	responseJSON, err := json.Marshal(customers)
	if err != nil {
		http.Error(w, "Error serializing customer details", http.StatusInternalServerError)
		log.Fatal(err)
		return
	}

	// Write JSON response
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	w.Write(responseJSON)
}

func CustomersCustomerIdPatch(w http.ResponseWriter, r *http.Request) {
	// Extract customerId from path parameters
	vars := mux.Vars(r)
	customerID := vars["customerId"]

	// Check if customerId is provided
	if customerID == "" {
		http.Error(w, "Missing customerId parameter", http.StatusBadRequest)
		return
	}

	// Set Content-Type header to indicate JSON response
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	// Read request body
	var updatedCustomerReq CustomerReq
	if err := json.NewDecoder(r.Body).Decode(&updatedCustomerReq); err != nil {
		http.Error(w, "Invalid input data", http.StatusBadRequest)
		return
	}

	// Retrieve database credentials
	db, err := connectToDB()
	if err != nil {
		http.Error(w, "Error connecting to database", http.StatusInternalServerError)
		log.Fatal(err)
		return
	}
	defer db.Close()

	// Begin transaction
	tx, err := db.Begin()
	if err != nil {
		http.Error(w, "Error starting transaction", http.StatusInternalServerError)
		return
	}

	// Update Customer table
	_, err = tx.ExecContext(context.Background(), `
		UPDATE Customer
		SET
			firstName = ?,
			lastName = ?,
			title = ?,
			familyStatus = ?,
			birthDate = ?,
			socialSecurityNumber = ?,
			taxId = ?,
			jobStatus = ?
		WHERE
			id = ?`,
		updatedCustomerReq.FirstName, updatedCustomerReq.LastName, updatedCustomerReq.Title, updatedCustomerReq.FamilyStatus,
		updatedCustomerReq.BirthDate, updatedCustomerReq.SocialSecurityNumber, updatedCustomerReq.TaxId, updatedCustomerReq.JobStatus,
		customerID)
	if err != nil {
		tx.Rollback()
		http.Error(w, "Error updating customer details "+err.Error(), http.StatusInternalServerError)
		return
	}

	// Update Address table if provided
	if updatedCustomerReq.Address != nil {
		_, err = tx.ExecContext(context.Background(), `
			UPDATE Address
			SET
				street = ?,
				houseNumber = ?,
				zipCode = ?,
				city = ?
			WHERE
				id = (SELECT addressId FROM Customer WHERE id = ?)`,
			updatedCustomerReq.Address.Street, updatedCustomerReq.Address.HouseNumber,
			updatedCustomerReq.Address.ZipCode, updatedCustomerReq.Address.City, customerID)
		if err != nil {
			tx.Rollback()
			http.Error(w, "Error updating address details "+err.Error(), http.StatusInternalServerError)
			return
		}
	}

	// Update BankDetails table if provided
	if updatedCustomerReq.BankDetails != nil {
		_, err = tx.ExecContext(context.Background(), `
			UPDATE BankDetails
			SET
				iban = ?,
				bic = ?,
				name = ?
			WHERE
				id = (SELECT bankDetailsId FROM Customer WHERE id = ?)`,
			updatedCustomerReq.BankDetails.Iban, updatedCustomerReq.BankDetails.Bic,
			updatedCustomerReq.BankDetails.Name, customerID)
		if err != nil {
			tx.Rollback()
			http.Error(w, "Error updating bank details "+err.Error(), http.StatusInternalServerError)
			return
		}
	}

	// Commit transaction
	if err := tx.Commit(); err != nil {
		http.Error(w, "Error committing transaction", http.StatusInternalServerError)
		return
	}

	// Respond with success message
	w.WriteHeader(http.StatusOK)
	fmt.Fprintf(w, "Customer updated")
}
